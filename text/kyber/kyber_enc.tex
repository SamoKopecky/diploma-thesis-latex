The encapsulation process relies on the encryption function (figure \ref{img:cpapke_enc}) and will be explained further. Firstly the parameters have to be setup. The public key is decoded into \rmhat{t}. The matrix \rmhat{A} is generated from $\rho$ which is also a part of the public key. A random polynomial vector \rmhat{r} is created and transformed into the NTT domain. Parameters $e_1$ and $e_2$ are also randomly generated where the~first one is another polynomial vector and $e_2$ is just a single polynomial. The last required parameter is the message $m$.

\rmhat{A} and \rmhat{r} are multiplied and $e_1$ is added to the result. Afterwards it is transformed from the NTT domain since booth factors are in NTT domain. The result of these operations is the $u$ which forms a part of the ciphertext. The message $m$ is decoded in order to create a~polynomial from it and decompressed. A polynomial is calculated using the factor of \rmhat{t} and \rmhat{r} and is again similarly transformed from the NTT domain. Then the polynomial $e_2$ is added to it together with the decoded message. To create the ciphertext booth $u$ and $v$ are compressed and encoded to get them ready for network transfer. The parameters used in the compression and encoding processes are $d_u$ and $d_v$ reference in table \ref{tab:kyber_sec_levels}.

\object[0.5]{obr}{pictures/kyber_enc.pdf}{Kyber encryption function}{img:cpapke_enc}

As a final step, a random key is generated and encrypted using the above defined encryption function. The resulting ciphertext is sent over to be decrypted.
