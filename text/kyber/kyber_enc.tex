The encapsulation process relies on the encryption function (figure \ref{img:cpapke_enc}) and will be explained further. Firstly the parameters have to be set up. The public key is decoded into \rmhat{t}. The matrix \rmhat{A} is generated from $\rho$ which is also a part of the public key. A random polynomial vector $r$ is created and transformed into the NTT domain. Parameters $e_1$ and $e_2$ are also randomly generated where the~first one is another polynomial vector and $e_2$ is just a single polynomial. The last required parameter is the randomly generated message $m$.

\rmhat{A} and \rmhat{r} are multiplied and $e_1$ is added to the result. Afterwards, it is transformed from the NTT domain since booth factors are in the NTT domain. The result of these operations is $u$ which forms a part of the ciphertext. The message $m$ is decoded to create a~polynomial from it and decompressed. A polynomial is calculated using the factor of \rmhat{t} and \rmhat{r} and is again similarly transformed from the NTT domain. Then the polynomial $e_2$ is added to it together with the decoded message. To create the ciphertext booth $u$ and $v$ are compressed and encoded to get them ready for network transfer. The parameters used in the compression and encoding processes are $d_u$ and $d_v$ reference in table \ref{tab:kyber_sec_levels}.

After the encapsulation process is done the entity that generated the random $m$ uses it to generate a random $K$ that will be used for some other purpose like a secret key for symmetric encryption.
\object[0.5]{obr}{pictures/kyber_enc.pdf}{Kyber encryption function}{img:cpapke_enc}
