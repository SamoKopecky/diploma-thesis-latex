At the beginning of the Dilithium signing process, the secret key has to be parsed into variables that it consists of. This is done by unpacking the bytes into useful data (see section \ref{sec:dil_bit_pack}), more specifically the vectors $s_1$, $s_2$, $tr$ and $t_0$. The NTT representation of $s_1$, $s_2$ can be precomputed ahead of time to increase the speed of singing. The parameter \rmhat{A} is generated from the shared seed $\rho$. The message to be signed is hashed together with $tr$ which is used for generating the vector $y$. For the sake of simplicity, this generation process is not described in \ref{img:dil_sign}. Next the product of \rmhat{A} and \rmhat{y} which is denoted $w$ is calculated. High bits (see section \ref{sec:dil_bit_man}) of $w$ (\texttt{hb(k)} in figure \ref{img:dil_sign}) are hashed together with the hash used for generating $y$, to create the polynomial $c$. It is first used for multiplying vectors $s_1$ and $s_2$. After that is used as a part of the signature. The vector $y$ is added to $cs_1$ ($cs_1$ is $s_1$ scaled by $c$) and creates another part of the signature, the vector $z$.

The subtraction of the vectors $w$ and $cs_2$ is added together with the scaled vector $ct_0$. The result of this process is used as the second input for the function \texttt{MakeHint}. The first input is a subtraction of $ct_0$ and $c$. \texttt{MakeHint} functions return the final value for the final signature.

\object[0.5]{obr}{pictures/dil_enc.pdf}{Dilithium signature creation}{img:dil_sign}
