At the beginning of the Dilithium signing process, the private key has to be parsed into variables that it consists of. This is done by unpacking the bytes into useful data (see section \ref{sec:dil_bit_pack}), more specifically the vectors $s_1$, $s_2$, $tr$ and $t_0$. The vectors $s_1$, $s_2$ need to be converted to the NTT form but this can be precomputed ahead of time to increase the speed of singing. The parameter \rmhat{A} is generated from the shared seed $\rho$. The message to be signed is hashed together with $tr$ which is used for generating the vector $y$. However for the sake of simplicity and clarity this generation process is not described in \ref{img:dil_sign} and the parameter $y$ is just shown as one of the inputs. Next the product of \rmhat{A} and \rmhat{y} which is denoted $w$ is calculated. High bits of $w$ (\texttt{hb(k)} in figure \ref{img:dil_sign}) are hashed together with the hash used for generating $y$, to create the polynomial $c$. It is first used for multiplying vectors $s_1$ and $s_2$. After that is used as a part of the signature. The vector $y$ is added to $cs_1$ ($cs_1$ is $s_1$ scaled by $c$) and creates another part of the signature, the vector $z$. The subtraction of the vectors $w$ and $cs_2$ is added together with the scaled vector $ct_0$. The result of this process is used as the second input for the function \texttt{MakeHint}. The first input is $ct_0$ but sign reverted. \texttt{MakeHint} functions return the final value for the final signature. These hints will then be used to calculate the missing part of the public key as described in \ref{subsec:dil_reducing_pub_key}.
