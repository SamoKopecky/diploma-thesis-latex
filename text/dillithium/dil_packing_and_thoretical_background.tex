Dilithium uses the same theoretical background as Kyber (see section \ref{sec:kyber_theroteical}) which includes rings, NTT transformation, polynomials and even uses the same $n$ as can be seen in table \ref{tab:dil_sec_levels}. However, the parameter $q$ is different.

\object[0.8]{obr}{pictures/bit_packing.pdf}{Bit packing for vectors $s_1$ and $s_2$}{img:bit_packing}

Since Dilithium needs to transfer polynomials over the network whose coefficients are different sizes from each other a very efficient bit-packing method can be used. For example the polynomial vectors $s_1$ and $s_2$ consist of values that are from the interval $\{-2,\,-1\,,0,\,1\,,2\}$ while using $\eta=2$. This means only 3 bits are required to pack a single coefficient into bit form (illustrated in figure \ref{img:bit_packing}). However the coefficients firstly need to be mapped into an interval $\{0,\,1\,,2,\,3\,,4\}$ while packing and moved back to $\{-2,\,-1\,,0,\,1\,,2\}$ in the unpacking process. As a result one polynomial of the mentioned vectors only takes up 96\,B and the whole polynomial vector in only takes up 384\,B. This is a big difference compared to the simple packing where one byte contains one value. A very similar process is used for packing other polynomial vectors in Dilithium, the only difference being the size of the coefficient interval. Using a~slightly different packing method for each kind of coefficient interval is what makes the bit packing/unpacking a very efficient method for encoding/decoding data that has to be sent over a network. This method is also used when a vector needs to be consumed by a hash function since it can only accept a byte array as its input.
