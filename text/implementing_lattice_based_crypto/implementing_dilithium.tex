As with Kyber, Dilithium is implemented using only the standard go libraries and one external library \cite{00fV2cvg7Z6H2tS3} that contains implementations for \texttt{SHAKE-128} and \texttt{SHAKE-256} hash functions. Dilithium can be implemented in two ways, the first one by using a bigger public key. This implementation of Dilithium is also simpler overall. The other option is implementing a more complex algorithm which has a~smaller public key by a factor of more then half. For this thesis the more complex implementation was chosen. The algorithm is explained at a very basic level in figure \ref{img:dil_all}. The small letter at the beginning of arrows denoted the size of the object. Firstly the public/secret keys are generated then the secret key is used in~the signing process. A signature is generated which then can be verified by anyone who owns the~related public key. Following sections explain all of these steps in~more detail with the help code snippets. As before with Kyber these code snippets can't be actually compiled and are only a Go styled pseudocode. For the~compilable implementation check the practical part of this thesis.

Table \ref{tab:dil_sec_levels} shows the individual parameters for each of the Dilithium parameter sets. The implementation in this thesis contains only Dilithium 2. When a parameter is relevant for the process being explained it will be mentioned and explained in that scenario instead of all the parameters being explained in this section.

\object{tab}{tables/dil_security_levels}{Dilithium security levels \cite{y0VQZiTmHEg2xvPn}}{tab:dil_sec_levels}
