The implementation of Kyber in this thesis is done using only the standard Go library with the exception of one external library \cite{00fV2cvg7Z6H2tS3} which is required for the implementations of the hash functions \texttt{SHAKE-128/256} and \texttt{SHA-3} (refer to section \ref{sec:hash_functions} for hash functions). Figure \ref{img:kyber_all} illustrates a very simplified block diagram of how Kyber works. The small letter or a number at the start of an arrow denotes the size of the object in polynomials. So for example the letter $k$ denotes that an object consists of $k$ polynomials. At first the public and secret key need to be generated. A~random message $m$ is then encrypted by one communicating entity using the~public key. The encrypted message is then decrypted by the other communicating entity and $m$ becomes the shared key. The following subsections will explain each sub algorithm of the block diagram in more detail along with code snippets. However the code snippets are only a go styled pseudocode and can't be actually compiled, check the practical part of this this for the compilable go source code.

\object{tab}{tables/kyber_security_levels}{Kyber security levels \cite{YbbuGxVPF0GGTxfN}}{tab:kyber_sec_levels}

Kyber uses a set of parameters to define its security level, of which it has three as seen in table \ref{tab:kyber_sec_levels}. Kyber in this thesis is only implemented for the parameters Kyber512. What individual parameters mean will be explained in further subchapters.


