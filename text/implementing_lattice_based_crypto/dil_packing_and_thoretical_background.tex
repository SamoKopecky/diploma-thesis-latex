Dilithium uses the same theoretical background as Kyber (see section \ref{subsec:kyber_theroteical}) which includes rings, NTT transformation, polynomials and even uses the same $n$ as can be seen in table \ref{tab:dil_sec_levels}.

\object[0.8]{obr}{pictures/bit_packing.pdf}{Bit packing for vectors $s_1$ and $s_2$}{img:bit_packing}

Since Dilithium needs to transfer polynomials over the network whose coefficients are different sizes form each other a very efficient bit packing method can be used. For example the polynomial vectors $s_1$ and $s_2$ are in an interval $\{-2,\,-1\,,0,\,1\,,2\}$ while using parameters for Dilithium 2. This means only 3 bits are required to pack a single coefficient into bit form (illustrated in figure \ref{img:bit_packing}). Although the coefficient firstly needs to be mapped into an interval $\{0,\,1\,,2,\,3\,,4\}$ while packing and moved back to $\{-2,\,-1\,,0,\,1\,,2\}$ in the unpacking process. As a result one polynomial of the mentioned vectors only takes up 96\,B and the whole polynomial vector in Dilithium 2 takes up 384\,B. A very similar process is used for packing other polynomial vectors in Dilithium, the only difference being the size of the coefficient interval. Using a slightly different packing method for each kind of coefficient interval is what makes the bit packing/unpacking a very efficient method for encoding/decoding data that has to be sent over a network. This method is also used when a vector needs to be consumed by a hash function.

