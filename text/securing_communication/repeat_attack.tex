If the attacker would be able to eavesdrop on the communication between two peers let's say, Alice and Bob, he could save the client init message and resend it again at a later time to initialize the connection again with being either client. Now Bob would think that he is accepting a connection from Alice, while in truth he's making a connection with the attacker.

To neutralize this type of attack a prevention mechanism is used in the form of timestamp cookies. As mentioned in \ref{subsec:init_phase} the client init message contains a 64\,b timestamp. In order to prevent time zone synchronization errors the Epoch time is used. When a server receives a client init, he first creates a name associated with the client's public key hash. If there is no cookie with this name, the server saves the timestamp in local storage together with the received timestamp. The cookie is always saved to a cookie directory listed in appendix \ref{ch:directories_app}. If a new client init message comes in from the same client containing a timestamp that is newer\,--\,meaning a higher number, meaning ahead of the current timestamp\,--\,the cookie is no longer created just updated with the new timestamp. On the other hand, if the server receives a client init with the same or older timestamp, he drops the connection since the timestamp was not updated with a newer one. This prevents the attack from repeating a client init message. Of course, this works only at the assumption that the first-ever connection from that client is a legitimate one.
