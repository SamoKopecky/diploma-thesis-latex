If the attack would be able to eavesdrop on the communication between two peers lets say Alice and Bob, he could save the client init message and resend them it again at a later time to initialize the connection again with being either client. Now Bob would think that he is accepting a connection from Alice, while in truth hes making a connection with the attacker.

To neutralize this type of attack a prevention mechanisms is used in the form of timestamp cookies. As mention in \ref{subsec:init_phase} the client init message contains a 64\,b timestamp. In order to prevent time zone synchronization errors the Epoch time is used. When a server receives a client init, he first creates a name associated with the clients public key hash. If there is no cookie with this name, the server saves the timestamp in local storage together with the received timestamp. The cookie is always saved to \texttt{\$HOME/.cache/pqcom}. If a new client init message comes in from the same client containing a timestamp that is newer\,--\,meaning a higher number, meaning ahead of the current timestamp\,--\,the cookie is no longer created just updated with the new timestamp. Ot the other hand if the server receives a client init with the same or older timestamp, he drops the connection since the timestamp was not updated with a newer one. This prevents the attack from repeating a client init message. Of course this works only at the assumption that the first ever connection from that client is a legitimate one.
