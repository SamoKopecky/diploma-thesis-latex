Before the initialization process can start client and server need to share each others public keys, this can easily be done by firstly generating a pair config files with the command \texttt{pqcom config gen}. Then one of the config files is moved to a peer that wants to connect to the other peer. Another approach would be to share each others public key. However it is very important to share either the public key or the config file out of band or by using another authenticated and secure communication channel.

After public keys have been exchanged, the process starts with client sending the \texttt{ClientInitT} message which is illustrated by figure \ref{img:clientinit_pdf}. This is the biggest message out of the four defined messages. It contains 7 fields in total.
\begin{itemize}
  \item \textbf{Header}\,--\,It servers the same purpose as in any other messages, to provide a message type and to delicate the payload length.
  \item \textbf{KEM and Sign Type}\,--\,These two fields exists for checking whether the two peers have the same algorithm ids configured in their configuration files. \textit{KEM Type} stores the ide for the key encapsulation method and the \textit{Sign Type} stores the digital signature algorithm. The ids that are used in these fields are defined while implementing algorithms via the modularity system (see section \ref{sec:algs_modularity}). Booth of the fields are 8 bytes long so for each algorithm type there are 255 possible algorithms.
  \item \textbf{Timestamp}\,--\,In order to prevent repeat attacks, a timestamp is always sent by the client. It contains the Epoch time in microseconds and is defined with the size of 64 bytes. How exactly this timestamp is used to prevent repeat attacks is described in subsection \ref{subsec:repeat attack}.
  \item \textbf{Public Encryption Key}\,--\,This field enables the server to encrypt a randomly generated symmetric key when he receives the client init message. The client can then decrypt the randomly generated encrypted symmetric key in order to establish a shared key for the symmetric cipher. The length of public key is defined by the KEM Type field.
  \item \textbf{Nonce}\,--\,The randomly generated nonce is utilized by the symmetric cipher and is shared in plaintext. Its length also depends on the symmetric cipher used to encrypt data payloads. While using AES-GCM-256 the nonce is 12 bytes long.
  \item \textbf{Signature}\,--\,To secure the above mentioned fields a digital signature is created to protect the authenticity of the whole message. Only the client can create a signature since he holds the private key in his configuration file. The public was shared with the server before hand so he can easily check whether a client init message was created by the client. The size of the signature is defined by the Sign Type field.
\end{itemize}
\object[0.6]{obr}{pictures/clientinitt.pdf}{Client inicialization message}{img:clientinit_pdf}

Once the server receives the client init message it first verifies its signature. Then it checks the timestamp and saved to a predefined location if nessescery, again to see how exactly this helps prevent the replay attack see subsection \ref{subsec:repeat attack}. Next it checks if the algorithm types are the same the ones in its configuration file. If all these checks are positive a random symmetric key is generated and encrypted using the public encryption key the client sent. Nonce is saved in memory to be used later during encryption/decryption. The \texttt{ServerInitT} message contains 3 fields as can be seen in figure \ref{img:serverinit_pdf}.
\begin{itemize}
  \item \textbf{Header}\,--\,Utilized for message type and length.
  \item \textbf{Key Ciphertext}\,--\,Encrypted symmetric key generated by the server. Only the client can decrypt it since, the keys were generated by him. There is no fixed length fot the ciphertext since its size depends on the KEM type field.
  \item \textbf{Signature}\,--\,In order to provide two way authentication the server has to digitally sign the server init message with the pre-configured private key. The signature can then be verified by the client who has the corresponding public key configured. As with the client init message signature, this signature size also depends on the received and configured Sign Type field.
\end{itemize}
\object[0.6]{obr}{pictures/serverinitt.pdf}{Server inicialization message}{img:serverinit_pdf}

Upon receive the server init message, the client first verifies its signature and decrypts the symmetric key with his private encryption key. Then the encrypted communication can start using a symmetric cipher and the shared symmetric key.
