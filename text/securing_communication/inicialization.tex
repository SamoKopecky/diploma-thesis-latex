Before the initialization process can start client and server need to share each other's public keys, this can easily be done by first generating a pair of config files with the command \texttt{pqcom config gen}. Then one of the config files is moved to a peer that wants to connect to the other peer. Another approach would be to share each other's public key. However, it is very important to share either the public key or the config file out of the band or by using another authenticated and secure communication channel.

After public keys have been exchanged, the process starts with the client sending the \texttt{ClientInitT} message which is illustrated by figure \ref{img:clientinit_pdf}. This is the biggest message out of the four defined messages. It contains six fields in total.
\begin{itemize}
  \item \textbf{Header}\,--\,It serves the same purpose as in any other message, to provide a message type and to dictate the payload length.
  \item \textbf{KEM and Sign Type}\,--\,These two fields exist for checking whether the two peers have the same algorithm IDs configured in their configuration files. KEM Type stores the id for the key encapsulation method and the Sign Type stores the digital signature algorithm. The ids that are used in these fields are defined while implementing algorithms via the modularity system (see section \ref{sec:algs_modularity}). Booth of the fields are 1 byte long so for each algorithm type there are 255 possible algorithms.
  \item \textbf{Timestamp}\,--\,To prevent repeat attacks, a timestamp is always sent by the client. It contains the Epoch time in microseconds and is defined with a size of 8 bytes. How exactly this timestamp is used to prevent repeat attacks is described in subsection \ref{subsec:repeat_attack}.
  \item \textbf{Public Encryption Key}\,--\,This field enables the server to encrypt a randomly generated symmetric key when he receives the client init message. The client can then decrypt the randomly generated encrypted symmetric key in order to establish a shared key for the symmetric cipher. The length of the public key is defined by the KEM Type field.
  \item \textbf{Signature}\,--\,To secure the above-mentioned fields a digital signature is created to protect the authenticity of the whole message. Only the client can create a signature since he holds the private key in his configuration file. The public key was shared with the server beforehand so he can easily check whether a client init message was created by the client. The size of the signature is defined by the Sign Type field.
\end{itemize}
\object[0.6]{obr}{pictures/clientinitt.pdf}{Client inicialization message}{img:clientinit_pdf}

Once the server receives the client init message it first verifies its signature. Then it checks the timestamp and saves it to a predefined location if nessescery, again to see how exactly this helps prevent the replay attack see subsection \ref{subsec:repeat_attack}. Next, it checks if the algorithm types are the same as the ones in its configuration file. If all these checks are positive a random symmetric key is generated and encrypted using the public encryption key the client sent. The \texttt{ServerInitT} message contains 3 fields as can be seen in figure \ref{img:serverinit_pdf}.
\begin{itemize}
  \item \textbf{Header}\,--\,Defines message type and length.
  \item \textbf{Key Ciphertext}\,--\,Encrypted symmetric key generated by the server. Only the client can decrypt it since the keys were generated by him. There is no fixed length for the ciphertext since its size depends on the KEM type field.
  \item \textbf{Signature}\,--\,In order to provide two-way authentication the server has to digitally sign the server init message with the pre-configured private key. The signature can then be verified by the client who has the corresponding public key configured. As with the client init message signature, this signature size also depends on the received and configured Sign Type field.
\end{itemize}
\object[0.6]{obr}{pictures/serverinitt.pdf}{Server inicialization message}{img:serverinit_pdf}

Upon receiving the server init message, the client first verifies its signature and decrypts the symmetric key with his private encryption key. Then the encrypted communication can start using a symmetric cipher and the shared symmetric key.
