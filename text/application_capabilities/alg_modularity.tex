Any key encapsulation method or digital signature can be added to this application. Modularity in this application works by implementing methods of a Go interface. An interface serves as a definition of methods, their parameters and return types without actually giving them an implementation. All of the interface methods need to be implemented for an algorithm to be a valid choice. Defined methods for the KEM interface are listed in \ref{lst:kem_int}. The first three methods are self-explanatory. Method \texttt{EkLen} needs to return the size of the public key, \texttt{CLen} returns the size of the ciphertext. \texttt{Id} needs to return a random number, which is not already returned by any other algorithms ranging from 0 to 255. If an ID is already taken by another KEM, the application will throw an error asking the user to change the ID.

The interface for signatures is shown in listing \ref{lst:sign_int}. As with the KEM interface, the signature interface apart from the first three methods also needs a method that returns an ID, private/public key length and the signature length. After implementing these interfaces they need to be added to a shared map contained in either \texttt{crypto/kem.go} or \texttt{crypto/sign.go} files. The key for the map entry is the algorithm name that will be used in the configuration file and the value is a pointer to the implemented interface (a Go \texttt{struct}). See the listing below for an example.
\listing{text/code/kem_go.txt}{KEM interface}{lst:kem_int}{1}{8}
\listing{text/code/sign_go.txt}{Signature interface}{lst:sign_int}{1}{9}
\listing{text/code/kem_go.txt}{KEM algorithms map}{lst:kem_map}{10}{13}
