In order to maximize performance of Kyber and Dilithium the implementation Go code needs to be optimized. However before the optimization process can begin a benchmarking process has to be established in order to create a baseline to compare to. The benchmarking process is described in section \ref{sec:cmd_benchmark} and was used during the optimization process. The measured speed of algorithms is rarely going to be same ten times in a row or even two times in a row, especially Kyber and Dilithium, where the speed of calculations depends on the generated keys. Even more when the generation of the keys is dependent on pseudo randomly generated values which in this case it is. This is why the result is going to be different every time a benchmark is run. So even if a code change that speeds up the algorithm is implemented the result might be worse. To combat this a benchmark is ran multiple times in a row to generate more data which then can be used to calculate the mean of those runs. The tool \texttt{benchstat} is able to calculate the mean and even the statistical deviance of the mean by using data from a benchmark run (in this case it has to be ran more then 6 times for the statistical data to be reliable). This way it is able to tell whether a change in the code was beneficial to the performance of the algorithm or if it was just statistical fluke.

Now that a proper baseline and a benchmarking process has been established the optimization can begin. Preallocation instead of appending is one of the best ways to optimize a Go program especially Kyber and Dilithium where the program has to iterate over large arrays. When appending to an array in Go, the arrays size is increased dynamically depending on the number of elements in it. This means every time the size of the array is exceeded a new array has to be allocated and the contents of the old array has to be moved. This takes up a lot of instructions. A better way of appending in this situation is to preallocate the required amount of memory for the array and just insert elements into the array.

Another important thing to keep in mind while optimizing is that division is much more time consuming operation then others. It is always preferable to use multiplication or bit shifting together with basic binary operations like AND and OR when possible over division. A good example is byte decomposition, since this operation is used a lot in Kyber and Dilithium. One of the straightforward solutions might be to divide a number by the powers of 2 up to 8 and then reduce the result modulo two to get the bit in that position (see listing \ref{lst:div_b_to_b}).
\listing{text/code/optimizations_go.txt}{Byte decomposition using division and modulo}{lst:div_b_to_b}{5}{7}
\noindent This approach is slow compared to some other possible approaches because it uses division which is a slow operation. Additionally the result is converted to an integer which basically wastes all the instructions that were used to calculate the decimal points of the division result. A better approach would be to first shift the number right for each bit of the number. So for an 8 bit number (a byte) shift the number by the bit position. Then AND the shifted number with a mask of value 0x1. The result will be the bit in the position of the shift count. So for example by shifting the number 5 times and ANDing it with 0x1 the result will be the fifth least significant bit of the number. This implementation can be seen in listing \ref{lst:bit_shift_b_to_b}.

Many more optimizations are used in the implementation of Kyber and Dilithium in this thesis and can seen by viewing the implementation source code.
\listing{text/code/optimizations_go.txt}{Byte decomposition using AND and bit shifting}{lst:bit_shift_b_to_b}{1}{3}
