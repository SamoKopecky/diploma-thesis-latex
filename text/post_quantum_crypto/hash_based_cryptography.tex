Hash based cryptography is mainly used for post quantum digital signatures. Any hash function can be used inside a hash based cipher as long as they are collision resistant. That means they don't rely on any hard mathematical problems, which makes their security requirement very low. Also because of this fact, every hash based cipher can be have many alternatives using many different hash functions. \cite{Bernstein2009}

First hash based scheme was proposed by Leslie Lamport in 1975. If the output of the chosen hash function $h$ is 256 bits, the private key $x$ consists of 256 pairs of random bit string, where each string is 256 bits long. The public key $y$ is then generated by hashing every random bit string. At this point the public and private key are
\begin{align}
  x & =(x_{0,0}, x_{0,1}, x_{1,0}, x_{1,1},\dots,x_{256, 0},x_{256, 1}),                   \\
  y & =(h(x_{0,0}), h(x_{0,1}), h(x_{1,0}), h(x_{1,1}),\dots,h(x_{256, 0}),h(x_{256, 1})).
\end{align}
Given a message $m$ which at first is hashed, the signature $\sigma$ consists of either $x_{0,0}$ if the first bit of the message hash its 0 or $x_{0,1}$ if its 1. This repeats for every bit of the hashed message. The resulting signature for a given message is
\begin{align}
  h(m)   & =(01\dots0)^{256},                           \\
  \sigma & =(x_{0,0}, x_{1,1}, \dots, x_{256,0})^{256}.
\end{align}
The verifier also hashes the message, generating the same hash. He then chooses hash values from the public key depending on the bit string of the message hash and creates $y_p$. Then he hashes each hash of the signature and generates $h(\sigma)$, which are
\begin{align}
  h(\sigma) & =(h(x_{0,0}), h(x_{1,1}), \dots, h(x_{256,0}))^{256}, \\
  y_p       & =(h(x_{0,0}), h(x_{1,1}), \dots, h(x_{256,0}))^{256}.
\end{align}
If $h(\sigma)=y_p$ then the signature is verified. However the signer cannot reuse the same private key since it was already used. That is why this algorithm is called Lamport's one time signature. \cite{Bernstein149}

The solution to one time hash based signatures was introduced by Ralph Merkle in 1979 and is called the Merkle's tree signature scheme. Key generation starts with generating a binary tree which always has $2^n$ leafs, this is the master private key. Each leaf correspond to a hash of Lamport's public key. Every two neighboring nodes are hashed together to create their parent node. In figure \ref{img:merkel_tree} an example can be given for $N_1$ and $N_2$ where
\begin{equation}
  N_3=h(N_1, N_2).
\end{equation}
\object[1]{obr}{pictures/merkel-tree.pdf}{Merkel tree}{img:merkel_tree}
\noindent After the tree is generated the master public key is the root of the tree, in this case $N_{15}$. To sign a message, the signer chooses some random leaf node and signs a message with Lamport's one time signature using the corresponding private key. In this case $N_5$. To verify this signature, at first the one time signature is verified using Lamport's public key. The signature is verified but the public key also has to be verified. That is why the signer also sent the least amount of hashes need to compute the root. In this case he sent $N_4$, $N_3$, $N_{14}$ as seen in figure \ref{img:merkel_tree_path}. To calculate $N_{15}$, the verifier has to calculate
\begin{align}
  N_6    & =h(N_4,N_5)     \\
  N_7    & =h(N_6,N_3)     \\
  N_{15} & =h(N_{14},N_7).
\end{align}
If the calculated $N_{15}$ equals the master public key, the signature is verified. \cite{Bernstein2009}
\object[1]{obr}{pictures/merkel-tree-path.pdf}{Merkel tree -- signature verification}{img:merkel_tree_path}

As mentioned earlier, the security requirements for hash based ciphers are very low and the principles that they are based on are very well understood. This makes them an excellent candidate in NIST standardization process. However one flaw of these ciphers is that the signer has to keep record of previously signed messages hence they can produce only a limited amount of signatures. Although one signature has been standardized by NIST in the 3rd round and that is SPHINCS+, which is based on the aforementioned Merkle's tree signature.